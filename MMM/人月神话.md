## 代序

可直接用的程序占2%，另外3%需要做些修改，其余95%都是垃圾

软件行业普遍缺乏专业性，充满了业余人员

手里有一个锤子，看什么都是钉子

## 1.焦油坑

大型系统开发，大多数开发出了可运行的系统，不过只有少数满足目标、进度和预算的要求

程序->编程产品/编程系统->编程系统产品	总共要9倍成本

将做事方式调整到追求完美是学习编程的最困难部分

## 2.人月神话

缺乏合理的进度安排是造成项目滞后的最主要原因

------

### 乐观主义

#### 对估算技术缺乏有效的研究，反映了不真实假设——一切都将运作良好；每一项任务仅花费它所"应该"花费的时间

一切正常的概率非常小，甚至接近于零

#### 所有编程人员都是乐观主义者

按照时刻表完成进度的程序员一定会翻船

------

### 人月

隐含地假设人和月可以互换

人数和时间的互换仅适用于参与任务人员不需要相互交流

------

### 在若干人员中分解任务会引发额外的沟通工作量——培训和相互沟通

一个长期的项目必须预见到每年有20%的人员更替

------

### ~~软件任务的进度安排~~

1/3计划	计划要够多

1/6编码

1/4构件测试和早期系统测试	测试占一半，充分系统测试时间是非常重要的

1/4系统测试,所有构件已完成	当所有的一切看上去可以工作，已经被集成时，你至少还有四个月的工作需要完成

仅适用于瀑布模型，应被淘汰

------

### 软件开发者的时间分配（来自读者）

20%代码编辑

30%Debug

30%文档

20%保留时间

------

### 空泛的估算

作为一门学科，我们缺乏数据估计

满足顾客期望的日期而造成不合理的进度安排很普遍

#### 两种解决方案

##### 开发并推行生产率图表、缺陷率图表、估算规则等

##### 项目经理需要挺直腰杆，坚持他们的估计

就像厨师一样，即使外面的客人在等着上菜，一只鸡应该烤多久就要烤多久，不能因为妥协就用大火，这样只会将鸡烤焦

------

### Brooks法则

向进度落后的项目中增加人手，只会使进度更加落后

------

### 增派人手从三方面增加了项目必要的总体工作量

任务重新分配本身和所造成的工作中断

培训新人员

额外的相互沟通

## 3.外科手术队伍

### 效率高和效率低的实施者间个体差异非常大，经常能达到数量级的水平

优秀的专业程序员的生产率是较差的程序员的10倍

------

经验和实际表现没有联系

------

### 系统应该由尽可能少的人员来开发

如果在一个200人的项目中，有25个最能干和最有开发经验的项目经理，那么开除剩下175个程序员，让项目经理来开发

小型、精干队伍是最好的——思绪尽可能少

------

### 小型队伍的问题

对于真正意义上的大型系统，它太慢了

------

### 大型项目每一个部分由一个团队解决，该队伍以类似外科手术的方式组建

首席程序员

副手

管理员

编辑

文秘x2

程序职员

工具维护人员

测试人员

语言专家

## 4.贵族专制、民主政治和系统设计

在系统设计中，概念完整性是最重要的考虑因素

宁可少添加一些七七八八的功能，也应该保证整个系统体现的是一套完整的设计理念

概念完整性必须由一个人或非常少数互有默契的人员来实现

为了获得概念完整性，设计必须由一个人或者具有共识的小型团队来完成

对于非常大型的项目，将体系结构方面的工作与具体实现相分离是获得概念完整性的强有力方法（同样适用于小型项目）

## 5.画蛇添足

结构师必须牢记开发人员承担创造性和发明性的实现责任，所以结构师只能建议，不能支配

当实现产品时，某些次要特性的修改会造成意料不到的成本开销

避免开发第二个系统画蛇添足，运用自我约束准则，避免过于修饰。舍弃一些功能

## 6.贯彻执行

### 文档化的规格说明——手册

手册是产品的外部规格说明，它描述和规定了用户所见的每一个细节

不仅要描述包括界面在内的用户可见的一切，还要避免描述用户看不见的事物

结构师不应试图支配特性的具体实现过程

精确比生动更加重要

------

### 形式化定义

不要携带两个时钟出海，带一个或三个

当实现充当标准时，必须防止对实现的任何修改

------

### 会议和大会

#### 周例会每周半天的会议

重点是创新而不仅仅是结论

如果达成共识，非常好；如果没有，则由首席结构师来决定

如果任何人对于结果过于不满，可以立刻诉诸项目经理，但是这种情况非常少见

#### 为了解决堆积的问题，举行年度大会，典型的年度大会持续两周（可考虑半年一次）

------

### 电话日志

对于存在疑问的实现人员，应鼓励他们打电话询问相应的结构师，而不是一边自行猜测一边工作

有用的机制：保存电话日志，记录每一个问题和相应的回答。每周对日志进行合并整理，分发给用户和实现人员。

------

### 产品测试

产品测试小组是顾客的代理人，专门寻找缺陷

## 7.为什么巴比伦塔会失败

### 巴比伦塔的管理教训

缺乏交流与组织

------

### 大型编程项目中的交流

#### 非正式途径

#### 会议

#### 工作手册

##### 对项目必须产出的一系列文档进行组织的一种结构

##### 工作手册的实时更新与变更说明很重要

工作手册的使用者应该将注意力集中在上次阅读后的变更以及关于这些变更重要性的评述上

------

### 大型编程项目的组织架构——树状编程队伍

#### 任务

#### 产品负责人

组建团队，划分工作和制定进度表

#### 技术主管或结构师

对设计进行构思、提供整个设计的一致性和概念完整性、控制系统的复杂程度、提供问题的解决方案、根据需要调整系统设计

攻坚小组中的独行侠

他的沟通交流在团队中是首要的

他的工作几乎是完全技术性的

#### 进度

#### 人力的划分

#### 传统的树状组织结构反映了权力的结构原理——不允许双重领导

#### 各部分之间的接口定义

------

### 产品负责人和技术主管的关系

#### 为同一个人，适合3-6人的小型团队

思考者很少，实干家更少，既是思考者又是实干家的太少了

#### 产品负责人是总指挥，技术主管充当左右手

困难：很难在技术主管不参与任何管理工作的同时，建立其在技术决策上的权威

好处：项目经理可以使用并不很擅长管理的技术天才来完成工作

大型项目比较合适

#### 技术主管是总指挥，产品负责人充当左右手

技术主管需要一个管理人员（外科手术队伍）

小型项目比较合适

## 8.胸有成竹

工作量=常数x指令数量e1.5

大型项目：程序员数量超过25人

编译器的复杂度是批处理的三倍，操作系统复杂度是编译器的三倍

全职程序员仅将50%的时间用于编程和调试

## 9.削足适履

除了运行时间之外，程序所占据的内存空间也是主要开销。特别对于操作系统，它的很多程序是永久驻留在内存中的

培养开发人员从系统整体出发、面向用户的态度是软件编程管理人员最重要的职能

编程需要技术积累，每个项目需要自己的标准组件库

## 10.提纲挈领

少数文档是关键枢纽，是项目经理最重要的个人工具

------

### 为什么要有正式的文档

书面记录决策是必要的。只有记录下来，分歧才会明朗，矛盾才会突出。

文档能作为同其他人的沟通渠道。许多理应被普遍认同的策略，完全不为团队的一些成员所知。

文档可以作为数据基础和检查列表

------

### 项目经理的基本职责是使每个人都向着相同的方向前进，所以他的主要工作是沟通，而不是做决定。

文档使各项计划和决策在整个团队范围内得到交流

------

只有一小部分管理人员的时间——可能只是20%——用来从自己头脑外部获取信息

## 11.未雨绸缪

### ~~必须构建一个用来抛弃的系统~~

系统的丢弃与重新设计可以一步完成，也可以一块块的实现，但这是必须完成的步骤

为舍弃而计划，无论如何，你一定要这样做

20年后该建议是错误地

------

开发人员交付的是用户满意度，而不仅仅是实际的产品

用户的实际需要和用户的感觉会随着程序的构建、测试和使用而变化

每个产品都应该有数字版本号。每个版本都应该有自己的日程表和冻结日期，在此之后的变更属于下一个版本的范畴

------

### 对于一个广泛使用的程序，其维护成本通常是开发成本的40%或更多

维护成本受用户数目的影响。用户越多，所发现的错误也越多

设计人员越少、接口越少，产生的错误也就越少

------

缺陷修复总会以20%-50%的几率引入新的bug

理论上，在每次修复之后，必须重新运行先前所有的测试用例。从而确保系统不会以更隐蔽的方式被破坏。实际情况中，回归测试必须接近上述理想状况，所以它的成本非常高

事物在最初总是最好的

软件开发是减少混乱度的过程。软件维护是提高混乱度的过程

## 12.干将莫邪

项目经理应该制定一套策略，并为通用工具的开发分配资源

他还必须意识到专业工具的需求

系统软件开发中，交互式编程的生产率至少是原来的两倍

## 13.整体部分

许许多多的失败完全是因为那些产品未精确定义的地方而导致的

在编写任何代码之前，规格说明必须提交给外部测试小组，以详细地检查说明的完整性和明确性。开发人员无法自己完成这项工作

自上而下的设计从几个方面避免了bug

有时必须回退，推翻顶层设计，重新开始

开发大量的辅助调试平台和测试代码是值得的，代码量甚至可能有测试对象的一半

必须有人对变更和版本进行控制和文档化

## 14.祸起萧墙

一天一天的进度落后比起重大灾难更难以识别，更不容易防范和更加难以弥补

------

### 里程碑必须是具体的、特定的和可度量的事件，能进行清晰的定义

如果里程碑定义得非常明确，无法自欺欺人，很少有人会就里程碑的进展弄虚作假

如果里程碑很模糊，老板就常常会得到一份与实际情况不符的报告

------

当里程碑没有正确反映损失的时间，并对人们形成误导，以致事态无法挽回的时候，它会彻底打击小组的士气

对软件开发团队来说，进取是非常必要的

必须关心每一天的滞后，它们是大灾祸的基本组成要素

------

### 减少角色冲突

老板必须规范自己，不对项目经理可以解决的问题做出反应，并且决不在检查状态报告的时候做安排

------

### 猛地拉开地毯

拥有能了解真相的评审机制是必要的

------

计划日期是项目经理的工作产物，它是合理计划之前的判断

估计日期是最基层经理的工作产物，是对实际实现日期的判断

项目经理必须停止对这些日期的怀疑，将重点放在使其更加精确上，以便得到没有偏见的估计

对于大型项目，计划与控制团队是无价之宝

## 15.另外一面

即使是完全开发给自己使用的程序，描述性文字也是必需的，因为它们会被用户-作者所遗忘

------

### 每一份发布的程序拷贝应该包括一些可以理性运行的小测试用例，为用户提供信心

常规数据

合法边界

非法数据

------

流程图被鼓吹的程度远大于它们的实际作用

把文档整合到源程序，自文档化

段落注释的广泛使用在任何语言中都是一个很棒的实践

## 16.没有银弹

在获取和制定软件需求时，将快速原型开发作为迭代计划的一部分

------

### 软件系统的内在特性

#### 复杂度

#### 一致性

保持与其它接口的一致性

#### 可变性

功能变更，超越边界

要与各种新生事物保持一致

#### 不可见性

------

### 以往解决次要困难的一些突破

高级语言

分时？

------

流程图是非常差劲的软件结构表达方法

构建软件最可能的彻底解决方案是不开发任何软件

用户不知道自己需要什么

------

### 增量开发

首先系统应该能够运行，即使未完成任何有用的功能

迫切要求自上而下设计

自上而下增长的软件

## 17.再论没有银弹

大多数有丰富经验的程序员都拥有自己的私人开发库，使用大约30%的重用代码来开发软件

重用是一件说起来容易，做起来难的事情。他同时需要良好的设计和卓越的文档

时间证明了要使模块能够重用，其成本非常高

可重用的构件的工作量是一次性构件的2-3倍

人们在上下文中学习，因此我们需要出版一些复合产品的例子，而不仅仅是零部件的库

## 20年后的《人月神话》

核心观点——概念完整性和结构师

------

### 开发第二个系统所引起的后果和频率猜测

为用户群的属性明确地记载各种猜测。清晰和错误都比模糊不清好得多

------

### 没有构建舍弃原型——瀑布模型是错误的

#### 第11章部分理论错误

#### 瀑布模型的谬误

假设所有错误发生在编码实现阶段，因此它们的修复可以很顺畅地穿插在单元和系统测试中

假设整个系统一次性地被构建，在所有地设计、大部分编码、部分单元测试完成之后，才为闭环的系统测试合并各个部分。

#### 必须存在逆向移动

------

### 增量开发模型更佳——渐进地精化

#### 构建闭环的框架系统

##### 在每个阶段，我们都拥有一个可运行的系统

可以很早就开始用户测试

可以采用按预算开发的策略，彻底保证不会出现进度或者预算超支的情况（以允许的功能牺牲作为代价）

#### Parnas产品族

将软件作为一系列相关的产品族来设计

将那些不易于变化的设计决策放置在树的根部

#### Microsoft的"每晚重建"方法

------

### 关于信息隐藏，Parnas是正确的，我是错误的

#### 编程人员被屏蔽而不是暴露在他人模块的内部结构面前。这种情况下，工作效率最高。

在面对变更时很健壮，更加适合作为变更设计的理念

------

### 人月到底有多少神话色彩？Boehm的模型和数据

第一次发布的成本最优进度时间，时间=2.5*估计人月的立方根

当计划进度比最优时间长时，成本曲线会缓慢攀升

当计划进度比最优进度短时，成本曲线会急剧升高

无论安排多少人手，几乎没有任何项目能够在少于3/4的最优时间内获得成功

在项目早期添加额外的人力比在后期添加更加安全一些

### 人就是一切（或者说，几乎是一切）

团队质量是项目成功最大的决定因素，实际上是下一个次要因素的4倍

《人件》：软件行业的主要问题实质上更侧重于社会学而不是科学技术

提高软件项目的质量的最好办法之一，就是找到合适的人